const expect = require('chai').expect;
const jwt = require('jsonwebtoken');
const sinon = require('sinon');

const authMiddleware = require('../middleware/is-auth');

describe('Auth Middleware', function(){
    it('should throw error if authorization header missing', function(){
        const req = {
            get : function(headerField){
                return null;
            }
        };
    
        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw('Not authenticated.');
    })

    it('throw error if authorization header does not have seperator', function(){
        const req = {
            get : function(headerField){
                return 'xyz';
            }
        };

        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw();
    })

    it('Should return userId after decoding the token', function(){
        const req = {
            get : function(headerField){
                return 'Bearer jljlkjlkjirfytrtrdtdtd';
            }
        };

        sinon.stub(jwt, 'verify'); 
        jwt.verify.returns({
            userId: 'abc'
        }); //"returns" is a method generated by 'sinon.stub'

        // jwt.verify = function(){ //overwriting method globally can have impact on other places
        // // so its not advicible
        //     return { userId: 'abc'};
        // };

        authMiddleware(req, {}, () => {});
        expect(req).to.have.property('userId');
        expect(req).to.have.property('userId', 'abc'); // to verify returned values
        expect(jwt.verify.called).to.be.true; //verify if function is called or not
        jwt.verify.restore(); //'restore'is again a method generated by 'sinon.stub'
    })

    it('throw error if authorization header can not be verified', function(){
        const req = {
            get : function(headerField){
                return 'Bearer xyz';
            }
        };

        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw();
    })
})

